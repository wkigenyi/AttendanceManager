/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package systems.tech247.clockinutil;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import net.sf.dynamicreports.jasper.builder.JasperReportBuilder;
import net.sf.dynamicreports.report.builder.DynamicReports;
import net.sf.dynamicreports.report.builder.column.ColumnBuilder;
import net.sf.dynamicreports.report.builder.column.TextColumnBuilder;
import net.sf.dynamicreports.report.builder.style.StyleBuilder;
import net.sf.dynamicreports.report.constant.HorizontalTextAlignment;
import net.sf.dynamicreports.report.datasource.DRDataSource;
import net.sf.dynamicreports.report.exception.DRException;
import org.netbeans.api.progress.ProgressHandle;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.StatusDisplayer;
import org.openide.util.Exceptions;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;
import org.openide.util.RequestProcessor;
import org.openide.util.lookup.AbstractLookup;
import org.openide.util.lookup.InstanceContent;
import systems.tech247.dbaccess.DataAccess;
import systems.tech247.hr.Employees;
import systems.tech247.hr.OrganizationUnits;
import systems.tech247.tareports.ReportMonthlyAttendance;
import systems.tech247.util.CapPreview;
import systems.tech247.util.NotifyUtil;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//systems.tech247.clockinutil//MonthlyAttendanceSummary//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "MonthlyAttendanceSummaryTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE", 
        persistenceType = TopComponent.PERSISTENCE_NEVER
)
@TopComponent.Registration(mode = "editor", openAtStartup = false)
@ActionID(category = "Window", id = "systems.tech247.clockinutil.MonthlyAttendanceSummaryTopComponent")

@Messages({
    "CTL_MonthlyAttendanceSummaryAction=Monthly Attendance Summary Report",
    "CTL_MonthlyAttendanceSummaryTopComponent=Monthly Attendance Summary Report",
    "HINT_MonthlyAttendanceSummaryTopComponent="
})
public final class MonthlyAttendanceSummaryTopComponent extends TopComponent {
    
    CapPreview enablePreview;
    InstanceContent content = new InstanceContent();
    AbstractLookup lkp = new AbstractLookup(content);
    Date from;
    Date to;
    public MonthlyAttendanceSummaryTopComponent() {
        initComponents();
        setName(Bundle.CTL_MonthlyAttendanceSummaryTopComponent());
        setToolTipText(Bundle.HINT_MonthlyAttendanceSummaryTopComponent());
        associateLookup(lkp);
        
        enablePreview = this::generateReport;
        content.add(enablePreview);
        // Get the current date
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.MONTH, -1);
        cal.set(Calendar.DAY_OF_MONTH, 1);
        
        jdcFrom.setDate(cal.getTime());
        int month = cal.get(Calendar.MONTH);
        
        while(cal.get(Calendar.MONTH) == month){
            cal.add(Calendar.MONTH, 1);
        }
        cal.add(Calendar.DAY_OF_MONTH, -1);
        jdcTo.setDate(cal.getTime());
        
        jdcTo.addPropertyChangeListener(new PropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                if(evt.getSource()== jdcTo && evt.getPropertyName()=="date"){
                    to = jdcTo.getDate();
                    //jdcFrom.setMaxSelectableDate(to);
                }
            }
        });
        
        jdcFrom.addPropertyChangeListener(new PropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                if(evt.getSource()== jdcFrom && evt.getPropertyName()=="date"){
                    from = jdcFrom.getDate();
                    //jdcTo.setMaxSelectableDate(from);
                }
            }
        });
        

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jdcFrom = new com.toedter.calendar.JDateChooser();
        jLabel2 = new javax.swing.JLabel();
        jdcTo = new com.toedter.calendar.JDateChooser();

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(MonthlyAttendanceSummaryTopComponent.class, "MonthlyAttendanceSummaryTopComponent.jLabel1.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(MonthlyAttendanceSummaryTopComponent.class, "MonthlyAttendanceSummaryTopComponent.jLabel2.text")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.TRAILING))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jdcTo, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 141, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jdcFrom, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 141, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(203, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jdcFrom, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jdcTo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addContainerGap(243, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private com.toedter.calendar.JDateChooser jdcFrom;
    private com.toedter.calendar.JDateChooser jdcTo;
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened() {
        // TODO add custom code on component opening
    }

    @Override
    public void componentClosed() {
        // TODO add custom code on component closing
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
        // TODO read your settings according to their version
    }
    
    void generateReport(){
        SimpleDateFormat dateNameFormat = new SimpleDateFormat("dd-MM-yyyy");
        SimpleDateFormat dateLabelFormat = new SimpleDateFormat("dd");
        SimpleDateFormat dateDBFormat = new SimpleDateFormat("yyyy-MM-dd");
        from = jdcFrom.getDate();
        to = jdcTo.getDate();
        List<Date> dateList = new ArrayList();
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(from);
        int month = calendar.get(Calendar.MONTH);
        
        StyleBuilder alignLeft = DynamicReports.stl.style().setHorizontalTextAlignment(HorizontalTextAlignment.LEFT);
        
        ProgressHandle ph = ProgressHandle.createHandle("Generating The Report");
        RequestProcessor.getDefault().post(new Runnable() {
            @Override
            public void run() {
                ph.start();
                ph.progress("Establishing the Date Range");
                
                do{
                    dateList.add(calendar.getTime());
                    calendar.add(Calendar.DAY_OF_MONTH, 1);
                }
                while (!calendar.getTime().after(to));
                StatusDisplayer.getDefault().setStatusText("Number Of Days: "+ dateList.size());
                int days  = dateList.size();
                //There are 7 constant columns: 
                        //1. Row Number
                        //2. Payroll Number
                        //3. Surname
                        //4. Other Name
                        //5. Department
                ColumnBuilder[] columns = new ColumnBuilder[days+6];
                String[] columnNames = new String[days+6];
                
                ph.progress("Setting up report columns");
                
                TextColumnBuilder<Integer> rowNumber = DynamicReports.col.column("No.","no",DynamicReports.type.integerType()).setStyle(alignLeft).setFixedWidth(22);
                columns[0] = rowNumber;
                TextColumnBuilder pcode = DynamicReports.col.column("PR Code","code",DynamicReports.type.stringType()).setColumns(12);
                columns[1] = pcode;
                TextColumnBuilder lname = DynamicReports.col.column("Sur-Name","surname",DynamicReports.type.stringType()).setColumns(24);
                columns[2] = lname;
                TextColumnBuilder fname = DynamicReports.col.column("Other Name","fname",DynamicReports.type.stringType()).setColumns(24);
                columns[3] = fname;
                TextColumnBuilder dept = DynamicReports.col.column("Dep't","dept",DynamicReports.type.stringType());
                columns[4] = dept;
                TextColumnBuilder abs = DynamicReports.col.column("ABS","abs",DynamicReports.type.integerType());
                columns[days+5] = abs;
                
                for(int i=0; i<dateList.size(); i++){
                    columns[i+5] = DynamicReports.col.column(dateLabelFormat.format(dateList.get(i)),dateNameFormat.format(dateList.get(i)),DynamicReports.type.stringType());
                }
                
                
                
                ph.progress("Creating Data Source");
                columnNames[0]="no";
                columnNames[1]="code";
                columnNames[2]="surname";
                columnNames[3]="fname"; //Filling in the initial fields
                columnNames[4]="dept";
                columnNames[days+5]="abs";
                
                for(int i=0; i< days; i++){
                    columnNames[i+5] = dateNameFormat.format(dateList.get(i));
                }
                NotifyUtil.info("Columns Added", columnNames.length+ " Columns", false);
                
                ph.progress("Adding The Data");
                DRDataSource dataSource = new DRDataSource(columnNames);
                
                List list = DataAccess.getDepartmentIDInSchedulePeriod(dateDBFormat.format(from), dateDBFormat.format(to));
                for (int a = 0; a< list.size(); a++){
                    int b = a+1;
                    OrganizationUnits u = DataAccess.entityManager.find(OrganizationUnits.class, list.get(a));
                    List<Employees> liste = DataAccess.getEmployeesPerDepartmentIDInScedulePeriod(dateDBFormat.format(from), dateDBFormat.format(to), u.getOrganizationUnitID());
                    for(int i=0; i<liste.size(); i++){
                        int k = i+1;
                        Employees e = liste.get(i);
                        ph.progress("Department: "+b+" / "+list.size()+" "+u.getOrganizationUnitName()+" "+k+" / "+liste.size()+" Data For " + e.getSurName()+" "+e.getOtherNames());
                        Object[] data = new Object[dateList.size()+6];
                        data[0] = i+1;
                        data[1] = e.getEmpCode();
                        data[2] = e.getSurName();
                        data[3] = e.getOtherNames();
                        data[4] = u.getOrganizationUnitName();
                        
                        for(int j=0;j<dateList.size();j++){
                            int l = j+1;
                            String date = dateDBFormat.format(dateList.get(j));
                            data[j+5] = DataAccess.getAttendanceComment(e.getEmployeeID(), date);
                            ph.progress("Department: "+b+" / "+list.size()+" "+u.getOrganizationUnitName()+" "+k+" / "+liste.size()+" Data For " + e.getSurName()+" "+e.getOtherNames()+" Day "+l);
                        }
                        data[days+5] = DataAccess.getAbsentDays(e.getEmployeeID(), from, to);
                        dataSource.add(data);
                        
                        
                    }
                }
                ph.progress("Almost Done");
                ReportMonthlyAttendance design = new ReportMonthlyAttendance(columns, columnNames, dataSource, dateNameFormat.format(from),dateNameFormat.format(to) );
                JasperReportBuilder report = design.getReport();
                    try {
                        report.show(false);
                        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
                    } catch (DRException ex) {
                        Exceptions.printStackTrace(ex);
                    }
                  
                
                
                
                ph.finish();
            }
        });
        
    }
}
